// cris ababei
//
// this is a sketch to have an Arduino Uno board use its SPI as Slave;
// it receives what another SPI sends as Master - in our case the SPI Master
// is inside the FPGA (but it could be another Arduino just as well);
//
// credit:
// https://forum.arduino.cc/t/spi-slave-mode-example-code/66617/5
//
///////////////////////////////////////////////////////////////////////////////
// 
// to set up SPI as Slave, we include the SPI.h Library; but, we do not 
// include the SPI.begin() instruction; inclusion of the SPI.h Library 
// helps to use use the following symbolic names and function of the Library:
//
// (1) SS: Slave Select which refers to DPin-10 of the Slave;
//   To enable the 'SPI Port' of the Slave, we must configure its direction 
//   as input so that the SPI Master can assert logic-low signal on this pin 
//   to select (enable Slave's SPI Port) the Slave for data communication.
// (2) MOSI: Master Out Slave - refers to DPin-11 of the Slave;
//   We must set its direction as input so that data coming from Master 
//   can enter into the SPDR Register of the Slave.
// (3) MISO: Master In Slave Out - refers to DPin-12 of the Slave;
//   We must set its direction as output so that data leaving the Slave 
//   can enter into the SPDR Register of the Master.
// (5) SCK: Serial Clock - refers to DPin-13 of the Slave;
//   We must set its direction as input so that the serial clock signal 
//   generated by Master can simultaneously 'clock out' data from its 
//   SPDR Register and 'clock in' the same data into SPDR Register of 
//   the Slave. This is reason for saying that SPI stands for 
//   'Synchronous Serial Peripheral Interface'.
// (4) SPI.attachInterrupt(): function/method enables the interrupt 
//   logic of the SPI Port of the Slave; result is: whenever 
//   a data bytes enters into the SPDR register of the Slave, the Slave 
//   is automatically interrupted; it goes to interrupt handler (i.e., ISR) 
//   and spends very short time there either to collect data from the SPDR 
//   Register or to set a flag to enable the MCU to collect data in the 
//   loop() function.

#include<SPI.h>

volatile int i = 0;
byte my_array[2];

///////////////////////////////////////////////////////////////////////////////
// 
// setup
//
///////////////////////////////////////////////////////////////////////////////

void setup()
{
  Serial.begin(115200);
  pinMode(SS, INPUT_PULLUP); // DPin-10
  pinMode(MOSI, INPUT); // DPin-11; set MOSI as INPUT;
  pinMode(MISO, OUTPUT); // DPin-12; set MISO as OUTPUT;
  pinMode(SCK, INPUT); // DPin-13; receive clock from Master;
  SPCR |= _BV(SPE); // turn on SPI in Slave Mode;
  SPI.attachInterrupt(); // activate SPI interrupt;
}

///////////////////////////////////////////////////////////////////////////////
// 
// main
//
///////////////////////////////////////////////////////////////////////////////

void loop(void)
{
  // version 1: 
  // just receive and print one byte at a time;
  if (i == 1) {
    //Serial.print("Received byte from Master: ");
    Serial.print(my_array[0], HEX);
    Serial.print(" ");
    i = 0;
  }

  // version 2: 
  // interpret each two received bytes as the upper and lower bytes
  // of a say int number represented on 16 bits; this kind of "interpretation"
  // of course would depend on what you want to do in your application
  // and what the SPI Master unit sends you;
  //if (i == 2) {
  //  int x = (int)my_array[0]<<8 | (int)my_array[1];
  //  Serial.print("Received 16-bit data item from Master: ");
  //  Serial.println(x, HEX);
  //  i = 0;
  //}
}

ISR (SPI_STC_vect) // interrupt handler, or iterrupt service routine; 
{
  my_array[i] = SPDR;
  i++;
}